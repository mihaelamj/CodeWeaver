<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iOS Interview Practice Test</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        max-width: 1000px;
        margin: 0 auto;
        padding: 20px;
        line-height: 1.6;
        background: #f8f9fa;
      }

      .header {
        text-align: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        border-radius: 12px;
        margin-bottom: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .section {
        background: white;
        margin-bottom: 20px;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        border-left: 5px solid;
      }

      .general {
        border-left-color: #9f7aea;
      }
      .project {
        border-left-color: #ecc94b;
      }
      .challenging {
        border-left-color: #4299e1;
      }
      .testing {
        border-left-color: #48bb78;
      }
      .swift {
        border-left-color: #ed8936;
      }
      .concurrency {
        border-left-color: #f56565;
      }
      .memory {
        border-left-color: #a0522d;
      }
      .sdk {
        border-left-color: #e2e8f0;
      }
      .macos {
        border-left-color: #2d3748;
      }
      .lifecycle {
        border-left-color: #ecc94b;
      }
      .architecture {
        border-left-color: #38a169;
      }

      .question {
        background: #f7fafc;
        padding: 20px;
        cursor: pointer;
        border-bottom: 1px solid #e2e8f0;
        transition: all 0.3s ease;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .question:hover {
        background: #edf2f7;
      }

      .question-text {
        font-weight: 600;
        color: #2d3748;
      }

      .toggle {
        font-size: 18px;
        color: #718096;
        transition: transform 0.3s ease;
      }

      .question.active .toggle {
        transform: rotate(180deg);
      }

      .answer {
        padding: 0 20px;
        max-height: 0;
        overflow: hidden;
        transition: all 0.4s ease;
        background: white;
      }

      .answer.show {
        max-height: 2000px;
        padding: 20px;
      }

      .answer-content {
        color: #4a5568;
        margin: 0;
      }

      .answer-content ul {
        margin: 10px 0;
        padding-left: 20px;
      }

      .answer-content li {
        margin-bottom: 8px;
      }

      .answer-content strong {
        color: #2d3748;
      }

      .progress {
        position: fixed;
        top: 0;
        left: 0;
        height: 4px;
        background: linear-gradient(to right, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
        z-index: 1000;
      }

      .stats {
        text-align: center;
        background: white;
        padding: 20px;
        border-radius: 12px;
        margin-bottom: 20px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      }

      .stat-item {
        display: inline-block;
        margin: 0 20px;
        padding: 10px;
      }

      .stat-number {
        font-size: 24px;
        font-weight: bold;
        color: #667eea;
      }

      .stat-label {
        font-size: 12px;
        color: #718096;
        text-transform: uppercase;
      }
    </style>
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-swift.min.js"></script>
  </head>
  <body>
    <div class="progress" id="progress"></div>

    <div class="header">
      <h1>ðŸ“± iOS Client Interview Practice Test</h1>
      <p>Comprehensive Q&A based on your prep material</p>
    </div>

    <div class="stats">
      <div class="stat-item">
        <div class="stat-number" id="totalQuestions">32</div>
        <div class="stat-label">Total Questions</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="answeredQuestions">0</div>
        <div class="stat-label">Reviewed</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="progressPercent">0%</div>
        <div class="stat-label">Progress</div>
      </div>
    </div>

    <!-- General Experience -->
    <div class="section general">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Tell me about your iOS development background and the types of apps
          you've built.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Structure your answer to include:</strong>
          <ul>
            <li>
              <strong>Career timeline:</strong> Years of experience, progression
              from junior to current level
            </li>
            <li>
              <strong>App types:</strong> Consumer apps (social, productivity,
              entertainment) vs enterprise apps (internal tools, B2B solutions)
            </li>
            <li>
              <strong>Platform scope:</strong> iPhone-only, universal apps,
              iPad-specific features
            </li>
            <li>
              <strong>Team dynamics:</strong> Solo development, small teams
              (2-5), larger teams (10+)
            </li>
            <li>
              <strong>Notable projects:</strong> Mention apps in the App Store,
              user base size, technical challenges solved
            </li>
          </ul>
          <strong>Example answer framework:</strong> "I have X years of iOS
          development experience, starting with [first role]. I've built both
          consumer apps like [example] with [user base] and enterprise solutions
          for [industry]. My experience ranges from solo development to working
          in agile teams of up to [number] developers."
        </div>
      </div>
    </div>

    <div class="section general">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Describe your code quality practices and development workflow.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Cover these essential practices:</strong>
          <ul>
            <li>
              <strong>Code Reviews:</strong> PR review process, what you look
              for, how you give/receive feedback
            </li>
            <li>
              <strong>Testing Strategy:</strong> Unit test coverage targets,
              integration testing approach
            </li>
            <li>
              <strong>Pull Request Workflow:</strong> Branch naming, commit
              message standards, CI/CD integration
            </li>
            <li>
              <strong>Quality Gates:</strong> Automated checks, linting rules,
              static analysis tools
            </li>
            <li>
              <strong>Documentation:</strong> Code comments, README files,
              technical specifications
            </li>
          </ul>
          <strong>Mention specific tools:</strong> Xcode, Git, fastlane,
          SwiftLint, SonarQube, Jenkins/GitHub Actions
        </div>
      </div>
    </div>

    <div class="section general">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >How do you handle App Store rejections and what's your experience
          with Apple support?</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Common rejection scenarios:</strong>
          <ul>
            <li>
              <strong>Privacy violations:</strong> Missing usage descriptions,
              unauthorized data collection
            </li>
            <li>
              <strong>UI/UX issues:</strong> Confusing navigation, missing
              functionality
            </li>
            <li>
              <strong>Performance problems:</strong> Crashes, excessive battery
              usage, slow loading
            </li>
            <li>
              <strong>Content policy:</strong> Inappropriate content, misleading
              information
            </li>
          </ul>
          <strong>Resolution approach:</strong>
          <ul>
            <li>Carefully read rejection feedback and Apple's guidelines</li>
            <li>Reproduce the issue in Apple's testing environment</li>
            <li>Document fixes clearly in resubmission notes</li>
            <li>
              Use App Store Connect to communicate with review team when needed
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- General Experience (additions) -->
    <div class="section general">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">Describe your experience with pair programming and TDD (Test-Driven Development) in iOS projects.</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Pair programming:</strong>
          <ul>
            <li>How you approach collaborative coding</li>
            <li>Benefits: knowledge sharing, code quality, onboarding</li>
            <li>Challenges: time management, communication</li>
          </ul>
          <strong>TDD:</strong>
          <ul>
            <li>How you write tests before code</li>
            <li>Impact on design, refactoring, and bug reduction</li>
            <li>Tools: XCTest, Quick/Nimble</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Project Management -->
    <div class="section project">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >How do you manage context switching and handle multiple overlapping
          responsibilities?</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Effective strategies include:</strong>
          <ul>
            <li>
              <strong>Time boxing:</strong> Dedicated blocks for different types
              of work (coding, reviews, meetings)
            </li>
            <li>
              <strong>Documentation:</strong> Detailed notes on current
              progress, next steps, blockers
            </li>
            <li>
              <strong>Priority matrix:</strong> Urgent/Important categorization,
              stakeholder alignment
            </li>
            <li>
              <strong>Context preservation:</strong> Meaningful commit messages,
              TODO comments, work-in-progress branches
            </li>
            <li>
              <strong>Communication:</strong> Regular status updates, proactive
              blocking issue escalation
            </li>
          </ul>
          <strong>Tools that help:</strong> JIRA/Linear for task tracking,
          Notion/Confluence for documentation, calendar blocking for deep work
        </div>
      </div>
    </div>

    <!-- Project Management (additions) -->
    <div class="section project">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What prioritization techniques do you use to focus on the most important tasks?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Moscow method (Must have, Should have, Could have, Won't have)</li>
            <li>Eisenhower matrix (urgent vs important)</li>
            <li>Regular backlog grooming and stakeholder alignment</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Challenging Environments -->
    <div class="section challenging">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Describe your approach to working with legacy codebases and
          unstructured environments.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Assessment phase:</strong>
          <ul>
            <li>
              <strong>Code exploration:</strong> Understand architecture,
              identify patterns and anti-patterns
            </li>
            <li>
              <strong>Risk analysis:</strong> Find critical paths, areas with
              high change frequency
            </li>
            <li>
              <strong>Test coverage review:</strong> Identify gaps, prioritize
              areas for testing
            </li>
            <li>
              <strong>Documentation audit:</strong> What exists, what's missing,
              what's outdated
            </li>
          </ul>
          <strong>Improvement strategy:</strong>
          <ul>
            <li>
              <strong>Incremental refactoring:</strong> Small, safe changes with
              immediate testing
            </li>
            <li>
              <strong>Strangler pattern:</strong> Gradually replace old code
              with new implementation
            </li>
            <li>
              <strong>Safety nets:</strong> Add tests before making changes,
              feature flags for rollback
            </li>
            <li>
              <strong>Knowledge sharing:</strong> Document findings, create team
              learning sessions
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Challenging Environments (additions) -->
    <div class="section challenging">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you approach refactoring and making incremental improvements in a legacy codebase?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Identify high-risk areas and add tests before refactoring</li>
            <li>Break down large changes into small, reviewable steps</li>
            <li>Use feature flags for safe rollout</li>
            <li>Document changes and share knowledge with the team</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Testing & Code Quality -->
    <div class="section testing">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Explain your unit testing practices and test structure
          organization.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Testing framework and structure:</strong>
          <ul>
            <li>
              <strong>XCTest:</strong> Standard iOS testing framework, test case
              organization
            </li>
            <li>
              <strong>Test naming:</strong> Descriptive names like
              test_methodName_condition_expectedResult
            </li>
            <li>
              <strong>Test organization:</strong> Group by feature/class,
              separate unit/integration/UI tests
            </li>
            <li>
              <strong>Setup/Teardown:</strong> Clean test isolation, shared test
              utilities
            </li>
          </ul>
          <pre><code class="language-swift">
func test_userLogin_validCredentials_returnsSuccess() {
    // Given
    let credentials = UserCredentials(email: "test@example.com", password: "valid")
    let mockService = MockAuthService()
    // When
    let result = authManager.login(with: credentials)
    // Then
    XCTAssertTrue(result.isSuccess)
}
          </code></pre>
        </div>
      </div>
    </div>

    <div class="section testing">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >How do you implement dependency injection in iOS? Discuss different
          approaches.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Constructor Injection (Preferred):</strong>
          <pre><code class="language-swift">
class UserViewModel {
    private let apiService: APIServiceProtocol
    private let analytics: AnalyticsProtocol
    init(apiService: APIServiceProtocol, analytics: AnalyticsProtocol) {
        self.apiService = apiService
        self.analytics = analytics
    }
}
          </code></pre>
          <strong>Environment Pattern:</strong>
          <pre><code class="language-swift">
struct Environment {
    var analytics: AnalyticsClient
    var dateProvider: () -> Date
    var uuidProvider: () -> UUID
}
          </code></pre>
          <strong>Factory Pattern:</strong>
          <ul>
            <li>Use when multiple instances needed</li>
            <li>Lazy instantiation requirements</li>
            <li>Complex creation logic</li>
          </ul>
          <strong>Avoid:</strong> Service locators, hidden singletons, global
          state
        </div>
      </div>
    </div>

    <!-- Testing & Code Quality (additions) -->
    <div class="section testing">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you use mocking in your tests? Manual mocks vs libraries?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Manual mocks: custom classes conforming to protocols</li>
            <li>Libraries: Cuckoo, Mockingbird, Sourcery</li>
            <li>When to use each: simple dependencies vs complex behaviors</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="section testing">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are the pros and cons of using singletons for dependency injection?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Pros: easy access, global state, simple for small apps</li>
            <li>Cons: hard to test, hidden dependencies, tight coupling</li>
            <li>Alternatives: constructor injection, environment pattern</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Swift vs Objective-C -->
    <div class="section swift">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Compare Swift and Objective-C. What are the key advantages of
          Swift?</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Swift advantages:</strong>
          <ul>
            <li>
              <strong>Type Safety:</strong> Compile-time error detection,
              reduced runtime crashes
            </li>
            <li>
              <strong>Optionals:</strong> Explicit null handling, eliminates
              null pointer exceptions
            </li>
            <li>
              <strong>Modern syntax:</strong> Cleaner, more readable code,
              functional programming features
            </li>
            <li>
              <strong>Performance:</strong> Optimized compilation, value types,
              reduced overhead
            </li>
            <li>
              <strong>Memory management:</strong> Automatic reference counting
              with safer patterns
            </li>
          </ul>
          <strong>Swift enums vs ObjC:</strong>
          <ul>
            <li>Associated values and pattern matching</li>
            <li>Methods and computed properties on enums</li>
            <li>Exhaustive switch statements</li>
          </ul>
          <strong>Interoperability:</strong> Bridging headers, @objc attributes,
          mixed-language projects
        </div>
      </div>
    </div>

    <!-- Swift vs Objective-C (additions) -->
    <div class="section swift">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you bridge between Swift and Objective-C in a mixed codebase?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Use bridging headers to expose Objective-C to Swift</li>
            <li>@objc and dynamic keywords to expose Swift to Objective-C</li>
            <li>Limitations: enums, generics, some Swift-only features</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="section swift">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How would you call C or C++ code from Swift if needed?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Use bridging headers for C</li>
            <li>For C++, create Objective-C++ wrappers (.mm files) and expose via Objective-C</li>
            <li>Limitations: no direct C++ to Swift bridging</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Concurrency -->
    <div class="section concurrency">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Explain Swift's modern concurrency features (async/await, actors) vs
          traditional approaches.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Modern Swift Concurrency:</strong>
          <pre><code class="language-swift">
// Async/await
func fetchUserData() async throws -> User {
    let data = try await networkService.fetch("/user")
    return try JSONDecoder().decode(User.self, from: data)
}
// Actor for thread-safe state
actor UserStore {
    private var users: [User] = []
    func addUser(_ user: User) {
        users.append(user)
    }
}
          </code></pre>
          <strong>Traditional approaches comparison:</strong>
          <ul>
            <li>
              <strong>DispatchQueue:</strong> Manual thread management, callback
              complexity
            </li>
            <li>
              <strong>NSOperationQueue:</strong> More control but more
              boilerplate
            </li>
            <li>
              <strong>Combine:</strong> Reactive programming, good for data
              streams
            </li>
          </ul>
          <strong>When to choose each:</strong>
          <ul>
            <li>
              <strong>Async/await:</strong> Simple asynchronous operations, API
              calls
            </li>
            <li>
              <strong>Actors:</strong> Shared mutable state, thread-safe data
              access
            </li>
            <li>
              <strong>Combine:</strong> UI binding, complex data transformation
              pipelines
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Concurrency (additions) -->
    <div class="section concurrency">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">When would you use semaphores in iOS, and what are the risks?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Use for synchronizing access to resources, limiting concurrency</li>
            <li>Risks: deadlocks, priority inversion, complexity</li>
            <li>Prefer higher-level abstractions (DispatchQueue, actors) when possible</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Memory Management -->
    <div class="section memory">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Explain value types vs reference types in Swift and their performance
          implications.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Value Types (Structs, Enums):</strong>
          <ul>
            <li>
              <strong>Copy semantics:</strong> Each instance is independent
            </li>
            <li>
              <strong>Stack allocation:</strong> Faster allocation/deallocation
            </li>
            <li>
              <strong>Thread safety:</strong> No shared mutable state by default
            </li>
            <li>
              <strong>Use for:</strong> Data models, small objects, immutable
              data
            </li>
          </ul>
          <strong>Reference Types (Classes):</strong>
          <ul>
            <li><strong>Reference semantics:</strong> Shared instances</li>
            <li>
              <strong>Heap allocation:</strong> ARC overhead, potential retain
              cycles
            </li>
            <li>
              <strong>Identity:</strong> Can compare instance identity (===)
            </li>
            <li>
              <strong>Use for:</strong> Complex objects, inheritance
              hierarchies, identity-important objects
            </li>
          </ul>
          <strong>Performance considerations:</strong>
          <ul>
            <li>
              Large structs: Consider reference types to avoid expensive copies
            </li>
            <li>Small classes: Consider structs to reduce heap allocation</li>
            <li>Copy-on-write for collections to optimize struct copying</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Memory Management (additions) -->
    <div class="section memory">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are some ARC edge cases and how do you handle them?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Unowned references: use when the reference should never be nil, but can crash if accessed after deallocation</li>
            <li>Weak references: use for optional, non-owning references</li>
            <li>Closures capturing self: use [weak self] or [unowned self] to avoid retain cycles</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="section memory">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you decide between using a struct, class, or actor for a given type?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Struct: value semantics, simple data, thread safety</li>
            <li>Class: reference semantics, identity, inheritance</li>
            <li>Actor: shared mutable state, concurrency safety</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- SDKs & Libraries (new section) -->
    <div class="section sdk">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are the tradeoffs between static and dynamic libraries in iOS?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Static: included in app binary, faster launch, larger app size, no runtime updates</li>
            <li>Dynamic: loaded at runtime, smaller initial app size, can be updated independently, slower launch</li>
            <li>Choose based on update needs, app size, and performance requirements</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="section sdk">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you approach building reusable internal SDKs or modules?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Define clear APIs and documentation</li>
            <li>Use Swift Package Manager or CocoaPods for distribution</li>
            <li>Write tests and provide example usage</li>
            <li>Versioning and changelog for updates</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- macOS vs iOS -->
    <div class="section macos">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are the main differences in file system and sandboxing between iOS and macOS?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>iOS: strict sandboxing, limited file access, app-specific containers</li>
            <li>macOS: more flexible, user-selected file access, sandboxing optional for non-App Store apps</li>
            <li>Impacts on document handling, security, and inter-app communication</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="section macos">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you share codebases for multiplatform (iOS/macOS) apps?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Use Swift Package Manager for shared modules</li>
            <li>Conditional compilation (#if os(iOS), #if os(macOS))</li>
            <li>Platform-agnostic APIs and abstractions</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- App Lifecycle -->
    <div class="section lifecycle">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Describe the changes in iOS app lifecycle management post-iOS 13 with
          SceneDelegate.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Pre-iOS 13 (AppDelegate only):</strong>
          <ul>
            <li>Single app instance, simple lifecycle management</li>
            <li>
              Methods: didFinishLaunching, willEnterForeground,
              didEnterBackground
            </li>
          </ul>

          <strong>iOS 13+ (SceneDelegate):</strong>
          <ul>
            <li>
              <strong>Multi-scene support:</strong> Multiple windows/scenes per
              app
            </li>
            <li>
              <strong>AppDelegate:</strong> App-level events, scene session
              management
            </li>
            <li>
              <strong>SceneDelegate:</strong> Scene-specific lifecycle, UI state
              management
            </li>
          </ul>

          <strong>Key SceneDelegate methods:</strong>
          <pre><code class="language-swift">
func scene(_ scene: UIScene, willConnectTo session: UISceneSession)
func sceneDidBecomeActive(_ scene: UIScene)
func sceneWillResignActive(_ scene: UIScene)
func sceneDidEnterBackground(_ scene: UIScene)
          </code></pre>

          <strong>State restoration:</strong>
          <ul>
            <li>Scene-based state preservation</li>
            <li>User activity continuation between scenes</li>
            <li>Background app refresh per scene</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- App Lifecycle (additions) -->
    <div class="section lifecycle">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you handle background modes and background execution timing in iOS?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Enable background modes in Xcode (location, audio, fetch, etc.)</li>
            <li>Understand system constraints: limited execution time, power management</li>
            <li>Use background tasks and notifications for long-running work</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Architecture -->
    <div class="section architecture">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text"
          >Explain the SOLID principles and provide iOS-specific examples of
          each.</span
        >
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Single Responsibility Principle (SRP):</strong>
          <ul>
            <li>Each class should have only one reason to change</li>
            <li>
              <strong>Example:</strong> Separate UserViewModel (UI logic) from
              UserService (API calls)
            </li>
          </ul>

          <strong>Open/Closed Principle (OCP):</strong>
          <ul>
            <li>Open for extension, closed for modification</li>
            <li>
              <strong>Example:</strong> Protocol-based payment processors, add
              new payment methods without modifying existing code
            </li>
          </ul>

          <strong>Liskov Substitution Principle (LSP):</strong>
          <ul>
            <li>Derived classes must be substitutable for base classes</li>
            <li>
              <strong>Example:</strong> Any NetworkService implementation should
              work with existing code
            </li>
          </ul>

          <strong>Interface Segregation Principle (ISP):</strong>
          <ul>
            <li>Clients shouldn't depend on interfaces they don't use</li>
            <li>
              <strong>Example:</strong> Split large protocols into smaller,
              specific ones
            </li>
          </ul>

          <strong>Dependency Inversion Principle (DIP):</strong>
          <ul>
            <li>Depend on abstractions, not concretions</li>
            <li>
              <strong>Example:</strong> ViewModels depend on protocol, not
              concrete API service
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Architecture (additions) -->
    <div class="section architecture">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">Give a real-world example of applying architecture patterns in a modular iOS project.</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <ul>
            <li>Feature modules using MVVM or VIPER</li>
            <li>Shared networking and analytics modules</li>
            <li>Decoupled UI and business logic for testability</li>
            <li>Use of dependency injection for module boundaries</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Kean Blog Interviewer Questions -->
    <div class="section architecture">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">In your experience, what are the main challenges when migrating an existing codebase to Swift's async/await? How would you approach refactoring legacy completion-handler code?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Identifying async boundaries:</strong> Start by mapping out all functions that use completion handlers. Replace them with <code>async</code> functions, but do so incrementally to avoid breaking the codebase.</li>
            <li><strong>Error propagation:</strong> With <code>async/await</code>, errors are thrown instead of passed in a result. Refactor error handling logic to use <code>try/await</code> and <code>do/catch</code> blocks.</li>
            <li><strong>Cancellation:</strong> Use <code>Task</code> and <code>Task.cancel()</code> for cooperative cancellation, replacing manual cancellation tokens.</li>
            <li><strong>Testing:</strong> Update tests to use <code>async</code> test methods. Use <code>XCTestExpectation</code> only for legacy code.</li>
            <li><strong>Gradual migration:</strong> Use <code>withCheckedContinuation</code> to bridge between old and new code, allowing for stepwise migration.</li>
          </ul>
          <pre><code class="language-swift">// Before
func fetchData(completion: @escaping (Result<Data, Error>) -> Void) {
    network.request { result in
        completion(result)
    }
}
// After
func fetchData() async throws -> Data {
    return try await network.request()
}
</code></pre>
          <a href="https://kean.blog/post/web-api-client-async-await" target="_blank">Web API Client in Swift (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section concurrency">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">Can you explain the actor model in Swift and give a practical example of when you would use it over other concurrency primitives?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <p>Actors in Swift are reference types that protect their mutable state by isolating it from concurrent access. Only one task can access an actor's mutable state at a time, which prevents data races without manual locking.</p>
          <ul>
            <li><strong>When to use:</strong> Use actors for shared resources that are accessed from multiple concurrent tasks, such as caches, counters, or session managers.</li>
            <li><strong>Advantages:</strong> Simpler and safer than using <code>DispatchQueue</code> or locks. The compiler enforces isolation, so you can't accidentally access mutable state from outside the actor.</li>
            <li><strong>Limitations:</strong> Actors are reference types and can introduce performance overhead if overused. Use structs for value types and actors for shared, mutable state.</li>
          </ul>
          <pre><code class="language-swift">actor Counter {
    private var value = 0
    func increment() {
        value += 1
    }
    func getValue() -> Int {
        value
    }
}

// Usage:
let counter = Counter()
Task {
    await counter.increment()
    let current = await counter.getValue()
    print(current)
}
</code></pre>
          <a href="https://kean.blog/post/concurrency-done-right" target="_blank">Concurrency Done Right (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section sdk">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are some of the limitations or pain points you've encountered with Swift Package Manager integration in Xcode, and how have you worked around them?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Slow dependency resolution:</strong> Large projects with many dependencies can experience slow package resolution and build times. Workaround: Use fewer dependencies, or pre-build frameworks when possible.</li>
            <li><strong>Binary targets and resources:</strong> SPM has limited support for binary targets and resource bundles, which can complicate integration of SDKs that require them. Workaround: Use manual resource copying or fallback to CocoaPods for those dependencies.</li>
            <li><strong>Versioning and scripts:</strong> SPM lacks advanced versioning (e.g., pre-release tags) and custom build scripts. Workaround: Use post-build scripts in Xcode or manage versions manually.</li>
            <li><strong>Transitive dependency issues:</strong> Conflicts can arise if multiple packages depend on different versions of the same library. Workaround: Align versions across dependencies or fork packages if necessary.</li>
          </ul>
          <a href="https://kean.blog/post/swiftpm-xcode" target="_blank">SwiftPM and Xcode (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section sdk">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How would you design a modern web API client in Swift using async/await? What are the key considerations for error handling and testability?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Protocol-oriented design:</strong> Define an <code>APIClient</code> protocol to allow for dependency injection and mocking in tests.</li>
            <li><strong>Async/await for clarity:</strong> Use <code>async</code> functions for all network calls, which makes the code easier to read and maintain.</li>
            <li><strong>Error handling:</strong> Centralize error handling by mapping HTTP/network errors to custom error types. Use <code>do/catch</code> blocks in consumers.</li>
            <li><strong>Testability:</strong> Inject mock clients in tests to simulate network responses and errors. Write unit tests for each endpoint and error scenario.</li>
          </ul>
          <pre><code class="language-swift">protocol APIClient {
    func fetch<T: Decodable>(_ endpoint: String) async throws -> T
}

class MyAPIClient: APIClient {
    func fetch<T: Decodable>(_ endpoint: String) async throws -> T {
        let (data, _) = try await URLSession.shared.data(from: URL(string: endpoint)!)
        return try JSONDecoder().decode(T.self, from: data)
    }
}

// Example usage:
Task {
    do {
        let user: User = try await apiClient.fetch("https://api.example.com/user")
        print(user)
    } catch {
        print("Error: \(error)")
    }
}
</code></pre>
          <a href="https://kean.blog/post/web-api-client-async-await" target="_blank">Web API Client in Swift (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section sdk">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What features do you consider essential in a logging and network inspection tool for iOS? Have you used or contributed to tools like Pulse?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Real-time log viewing:</strong> Ability to see logs as they happen, with filtering and search.</li>
            <li><strong>Network inspection:</strong> View all HTTP requests and responses, including headers, bodies, and timing.</li>
            <li><strong>Pinning and grouping:</strong> Pin important logs, group by session or request, and annotate logs for later review.</li>
            <li><strong>Privacy and security:</strong> Mask sensitive data, redact tokens, and ensure logs are not leaked in production.</li>
            <li><strong>Integration:</strong> Export logs for bug reports, integrate with CI/CD, and support for crash reporting tools.</li>
          </ul>
          <p><strong>Pulse</strong> is an open-source tool that provides all of these features and is highly recommended for iOS development.</p>
          <a href="https://kean.blog/post/pulse-network-inspector" target="_blank">Pulse: Network Inspector (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section testing">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What do you think makes unit testing effective in Swift? How do you avoid writing tests that are a waste of time?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Test public API and business logic:</strong> Focus on testing the contract of your types, not private implementation details.</li>
            <li><strong>Keep tests fast and reliable:</strong> Avoid slow integration tests in your unit test target. Use mocks and stubs for dependencies.</li>
            <li><strong>Refactor for testability:</strong> If something is hard to test, refactor the code to make it easier, e.g., by injecting dependencies.</li>
            <li><strong>Maintainable tests:</strong> Write clear, descriptive test names and keep test code as clean as production code.</li>
            <li><strong>Avoid over-mocking:</strong> Only mock what you must. Over-mocking leads to brittle tests that break with refactoring.</li>
          </ul>
          <pre><code class="language-swift">// Example of a good test
func test_userLogin_success() {
    let mockService = MockAuthService()
    let viewModel = LoginViewModel(authService: mockService)
    mockService.shouldSucceed = true
    viewModel.login(username: "user", password: "pass")
    XCTAssertTrue(viewModel.isLoggedIn)
}
</code></pre>
          <a href="https://kean.blog/post/effective-unit-testing" target="_blank">Effective Unit Testing (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section architecture">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you decide between MVC, MVVM, and functional architectures in a new SwiftUI project? What are the tradeoffs?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>MVC:</strong> Simple and familiar, but can lead to "Massive View Controller" problem as the app grows. Good for small projects or prototypes.</li>
            <li><strong>MVVM:</strong> Separates UI from business logic, making code more testable and maintainable. More boilerplate, but scales better for medium to large projects.</li>
            <li><strong>Functional:</strong> Uses value types, immutability, and composition. Highly testable and predictable, but requires a team comfortable with functional programming concepts.</li>
            <li><strong>Decision factors:</strong> Team experience, project size, need for testability, and long-term maintainability.</li>
          </ul>
          <pre><code class="language-swift">// Example: MVVM in SwiftUI
struct UserView: View {
    @ObservedObject var viewModel: UserViewModel
    var body: some View {
        Text(viewModel.username)
    }
}

class UserViewModel: ObservableObject {
    @Published var username: String = ""
    // Business logic here
}
</code></pre>
          <a href="https://kean.blog/post/lets-talk-architecture" target="_blank">Let's Talk Architecture (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section sdk">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are your best practices for writing documentation for a Swift framework or SDK? How do you ensure it stays up to date and useful?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Write clear API docs:</strong> Use Swift's documentation comments (<code>///</code>) for every public type and method. Include usage examples and edge cases.</li>
            <li><strong>Automate doc generation:</strong> Use DocC or Jazzy to generate and publish documentation sites automatically as part of CI/CD.</li>
            <li><strong>Keep docs in sync:</strong> Set up CI checks to fail builds if documentation coverage drops. Encourage code reviewers to check docs as part of PRs.</li>
            <li><strong>Encourage feedback:</strong> Make it easy for users to suggest improvements or report unclear docs, e.g., via GitHub issues.</li>
          </ul>
          <pre><code class="language-swift">/// Downloads an image from the given URL.
/// - Parameter url: The URL of the image.
/// - Returns: The downloaded UIImage.
func downloadImage(from url: URL) async throws -> UIImage
</code></pre>
          <a href="https://kean.blog/post/nuke-docs" target="_blank">Nuke Docs (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section general">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What motivates you to contribute to open source? How do you balance open source work with your main job?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Giving back:</strong> Open source is a way to contribute to the community and help others solve similar problems.</li>
            <li><strong>Learning and growth:</strong> Working on open source exposes you to new ideas, code reviews, and feedback from other developers.</li>
            <li><strong>Portfolio and reputation:</strong> Public contributions help build your professional reputation and can lead to job opportunities.</li>
            <li><strong>Balance:</strong> Set boundaries for open source time, prioritize issues, and avoid burnout by not overcommitting.</li>
          </ul>
          <p>Many developers, including Kean, recommend treating open source as a passion project, not a second job.</p>
          <a href="https://kean.blog/post/open-sourcing-pulse" target="_blank">Open-Sourcing Pulse (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section swift">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">What are the biggest challenges you've faced when building multiplatform (iOS/macOS/watchOS) apps with SwiftUI?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Platform-specific APIs:</strong> Not all SwiftUI features are available on every platform. Use <code>#if os()</code> checks and provide platform-specific implementations where needed.</li>
            <li><strong>Designing adaptive UIs:</strong> Create layouts that work well on all screen sizes and input methods (touch, mouse, keyboard).</li>
            <li><strong>Testing and debugging:</strong> Test on all platforms regularly, as bugs can be platform-specific. Use simulators and real devices.</li>
            <li><strong>Code organization:</strong> Structure code into shared modules and use conditional compilation to separate platform-specific code.</li>
          </ul>
          <pre><code class="language-swift">#if os(iOS)
typealias PlatformColor = UIColor
#elseif os(macOS)
typealias PlatformColor = NSColor
#endif
</code></pre>
          <a href="https://kean.blog/post/appkit-is-done" target="_blank">AppKit is Done (kean.blog)</a>
        </div>
      </div>
    </div>
    <div class="section testing">
      <div class="question" onclick="toggleAnswer(this)">
        <span class="question-text">How do you set up continuous integration for a Swift framework? What are the key steps to ensure reliability and fast feedback?</span>
        <span class="toggle">â–¼</span>
      </div>
      <div class="answer">
        <div class="answer-content">
          <strong>Answer:</strong>
          <ul>
            <li><strong>Automate builds and tests:</strong> Use CI tools like GitHub Actions or Bitrise to run builds and tests on every commit and pull request.</li>
            <li><strong>Multi-platform testing:</strong> Test on all supported platforms (iOS, macOS, etc.) and with multiple Swift/Xcode versions to catch compatibility issues early.</li>
            <li><strong>Static analysis and code coverage:</strong> Run SwiftLint, SonarQube, or similar tools, and enforce code coverage thresholds.</li>
            <li><strong>Fast feedback:</strong> Keep CI pipelines fast by caching dependencies and running only necessary jobs for each change.</li>
          </ul>
          <pre><code class="language-yaml"># Example: GitHub Actions workflow
jobs:
  build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '15.0'
      - name: Build and test
        run: xcodebuild test -scheme MyFramework -destination 'platform=iOS Simulator,name=iPhone 14'
</code></pre>
          <a href="https://kean.blog/post/ci-for-swift-frameworks" target="_blank">CI for Swift Frameworks (kean.blog)</a>
        </div>
      </div>
    </div>

    <script>
      let reviewedQuestions = new Set();

      function toggleAnswer(questionElement) {
        const answer = questionElement.nextElementSibling;
        const isCurrentlyOpen = answer.classList.contains("show");

        // Close all other answers
        document.querySelectorAll(".answer.show").forEach((ans) => {
          ans.classList.remove("show");
          ans.previousElementSibling.classList.remove("active");
        });

        // Toggle current answer
        if (!isCurrentlyOpen) {
          answer.classList.add("show");
          questionElement.classList.add("active");

          // Mark as reviewed
          const questionText =
            questionElement.querySelector(".question-text").textContent;
          reviewedQuestions.add(questionText);
          updateStats();
        }
      }

      function updateStats() {
        const total = document.querySelectorAll(".question").length;
        const reviewed = reviewedQuestions.size;
        const percentage = Math.round((reviewed / total) * 100);

        document.getElementById("answeredQuestions").textContent = reviewed;
        document.getElementById("progressPercent").textContent =
          percentage + "%";
        document.getElementById("progress").style.width = percentage + "%";
      }

      // Initialize stats
      updateStats();

      // Keyboard shortcuts
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape") {
          // Close all answers
          document.querySelectorAll(".answer.show").forEach((ans) => {
            ans.classList.remove("show");
            ans.previousElementSibling.classList.remove("active");
          });
        }
      });
    </script>
  </body>
</html>
